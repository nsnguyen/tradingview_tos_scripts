# ============================================================
# README — UP‑streak / Top‑Reversal Scanner (Green bars)
# ============================================================
# What this does
#   • When topOn = no: flags symbols where the LAST N bars are ALL GREEN
#     (up‑streak). N is `consecutiveBars`.
#   • When topOn = yes: detects a local TOP (first red after ≥ N green bars)
#     and then requires X red bars of confirmation. X is `topConfirmBars` and
#     you can choose to count the top bar via `includeTopInCount`.
#
# Timeframe & session
#   • This study respects the Stock Hacker Aggregation (5‑min, 15‑min, Day, etc.).
#   • Intraday signal uses Close > Open (set usePrevClose = no).
#   • Daily‑style signal uses Close > Close[1] (set usePrevClose = yes).
#   • Include/exclude extended hours from the Study filter’s gear menu.
#
# Quick mapping to common “UP” triggers
#   • FirstGreen  → set consecutiveBars = 1
#   • TwoUp       → set consecutiveBars = 2
#   • ThreeUp     → set consecutiveBars = 3
#   (These are contiguous GREEN bars ending on the most recent completed bar.)
#
# Visual reference (R = red/down, G = green/up)
# ... R R R R R R  G  G  G ...
#                ^  ^  ^
#                |  |  └─ triggers when set to ThreeUp
#                |  └──── triggers when set to TwoUp
#                └─────── triggers when set to FirstGreen
#
# Notes on “bottom counts or not?”
#   • The diagrams below are for intuition. This script’s up‑streak mode
#     (topOn = no) does not explicitly identify a “bottom” — it simply
#     requires the last N bars to be GREEN. To emulate “count the bottom”,
#     reduce N by 1 relative to your mental model.
#
# A) Bottom does NOT count (conceptual)
# You need 3 greens AFTER the bottom → triggers on the 3rd green after.
# ... R R R  G  G  G  G ...
#            ^  ^  ^  ^
#            |  |  |  └─ fires when N=3
#            |  |  └─── 2 after
#            |  └────── 1 after
#            └───────── bottom (not counted)
#
# B) Bottom DOES count (conceptual)
# Bottom counts as #1 → you need 2 more greens → triggers on the 2nd green after.
# ... R R R  G  G  G ...
#            ^  ^  ^
#            |  |  └─ fires when N≈2 (bottom considered #1 conceptually)
#            |  └─── +1 after
#            └────── bottom (counts as #1)
#
# Inputs you’ll likely tweak
#   • consecutiveBars   : N in the up‑streak mode (FirstGreen/TwoUp/ThreeUp = 1/2/3)
#   • minPrice, minAvgVol50 / body filters : basic quality gates
#   • topOn, topConfirmBars, includeTopInCount : only used for top‑reversal mode
#   • usePrevClose      : choose Close>Open (intraday) vs Close>Close[1] (daily‑style)
#
# Evaluation timing
#   • Fires on the most recent COMPLETED bar of the selected aggregation.
# ============================================================
# StreakUp (many greens) OR TopReversal (top + X down bars) — Daily or Intraday
# Aggregation:
#   - Daily:    set to Day, usePrevClose = yes  (green = Close > Close[1])
#   - Intraday: set to 5/15-min, usePrevClose = no (green = Close > Open)

################
# USER INPUTS  #
################
input minPrice         = 3.0;
input minAvgVol50      = 300000;        # liquidity guard (useful even intraday)
input consecutiveBars  = 3;             # how many prior GREEN bars define "many"
input usePrevClose     = no;            # no = intraday (Close>Open); yes = daily (Close>Close[1])

# Doji / tiny-body controls
input minBodyBP            = 10;        # body >= X bps of price (1 bp = 0.01%); 0 disables
input useStrictDoji        = yes;       # when yes, also require body as % of range
input minBodyFracOfRange   = 0.15;      # body >= 15% of bar range (only if strict)

# Streak-only extra filter (optional): require a minimum total RISE across the streak
input requireMinRise   = no;
input minRisePct       = 6.0;           # e.g., >= +6% over last N bars

# <<< SIMPLE FLAG TO TOGGLE TOP REVERSAL MODE >>>
input topOn                 = no;       # OFF = green streak; ON = top + X down bars
input topConfirmBars        = 3;        # X = number of RED bars AFTER the top (default 3)
input includeTopInCount     = yes;      # no = require X after the top; yes = count top as 1

################
# CORE LOGIC   #
################
def liquid  = Average(volume, 50) >= minAvgVol50;
def priceOk = close >= minPrice and liquid;

# --- Doji filters ---
def body = AbsValue(close - open);
def rng  = high - low;
def bodyOK_bp    = if minBodyBP <= 0 then yes else ((body / close) * 10000) >= minBodyBP;
def bodyOK_range = (if rng > 0 then body / rng else 0) >= minBodyFracOfRange;
def bodyOK       = if useStrictDoji then (bodyOK_bp and bodyOK_range) else bodyOK_bp;

# Green / Red (both must pass body gate)
def greenByOpen  = close > open      and bodyOK;
def greenByClose = close > close[1]  and bodyOK;
def redByOpen    = close < open      and bodyOK;
def redByClose   = close < close[1]  and bodyOK;

def greenBar = if usePrevClose then greenByClose else greenByOpen;
def redBar   = if usePrevClose then redByClose   else redByOpen;

# --- GREEN STREAK: last N bars are all green (contiguous, ending now)
def lastNAllGreen = Sum(greenBar, consecutiveBars) == consecutiveBars;

# Optional: total % rise across the streak window (close now vs close N bars ago)
def risePct = (close / close[consecutiveBars] - 1) * 100;

# -------------------------
# TOP REVERSAL (top + X red)
# -------------------------
# Track green streak length
rec greenStreak = if greenBar then greenStreak[1] + 1 else 0;

# "Top" = first RED after >= N greens
def firstRedAfterStreak = redBar and greenStreak[1] >= consecutiveBars;

# Confirm X red bars AFTER the top (or include the top bar as #1)
def shift = if includeTopInCount then Max(0, topConfirmBars - 1) else topConfirmBars;
def redsAll = if topConfirmBars <= 0 then yes else Sum(redBar, topConfirmBars) == topConfirmBars;

def topOK = firstRedAfterStreak[shift] and redsAll;

################
# FINAL PLOT   #
################
plot scan =
     priceOk
  and (
        ( !topOn
          and lastNAllGreen
          and (if requireMinRise then risePct >= minRisePct else yes)
        )
     or (  topOn
          and topOK
        )
      );